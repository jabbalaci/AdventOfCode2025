Example:

[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}

--------------------

x1: how many times the 1st button was pressed
    it increments the value at index position 3
x2: how many times the 2nd button was pressed
    it increments the values at index positions 1 and 3
...

Target:

Index 0 = 3
Index 1 = 5
Index 2 = 4
Index 3 = 7

Let x₁, x₂, x₃, x₄, x₅, x₆ be the number of presses for each button (non-negative integers).

Index 0: only the 5th and 6th buttons (because (0,2) and (0,1) contain 0)
x₅ + x₆ = 3

Index 1: only the 2nd and 6th buttons (because (1,3) and (0,1) contain 1)
x₂ + x₆ = 5

Index 2: the 3rd, 4th, and 5th buttons (because (2), (2,3), and (0,2) contain 2)
x₃ + x₄ + x₅ = 4

Index 3: the 1st, 2nd, and 4th buttons (because (3), (1,3), and (2,3) contain 3)
x₁ + x₂ + x₄ = 7

--------------------

I tried this:

>>> from z3 import *
>>> x1, x2, x3, x4, x5, x6 = Ints('x1 x2 x3 x4 x5 x6')
>>> s = Solver()
>>> s.add(x5+x6==3, x2+x6==5, x3+x4+x5==4, x1+x2+x4==7, x1>=0, x2>=0, x3>=0, x4>=0, x5>=0, x6>=0)
>>> print(s.check())
sat
>>> print(s.model())
[x4 = 0, x1 = 2, x2 = 5, x3 = 1, x5 = 3, x6 = 0]
>>>

However, this is not minimal (not optimal).

--------------------

Optimal solution:

from z3 import Optimize, Int, Sum

x = [Int(f'x{i}') for i in range(6)]

opt = Optimize()

opt.add(x[4] + x[5] == 3)    # Index 0
opt.add(x[1] + x[5] == 5)    # Index 1
opt.add(x[2] + x[3] + x[4] == 4)  # Index 2
opt.add(x[0] + x[1] + x[3] == 7)  # Index 3

for xi in x:
    opt.add(xi >= 0)

# Goal: minimize the sum
total = Sum(x)
opt.minimize(total)

if opt.check() == sat:
    m = opt.model()
    solution = [m[xi].as_long() for xi in x]
    print("Solution:", solution)
    print("Sum:", sum(solution))
else:
    print("No solution found")
